package ModernJavaInAction.c11UsingOptional;

import ModernJavaInAction.c11UsingOptional.optionalmodel.Car;
import ModernJavaInAction.c11UsingOptional.optionalmodel.Insurance;
import ModernJavaInAction.c11UsingOptional.optionalmodel.Person;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/***
 * Patterns for adopting Optionals
 */
public class P3PatternsForAdoptingOptionals {

    public static void main(String[] args) {

        /*
        Creating Optional objects
        Empty Optional
        You can get hold of an empty optional object by using the static factory method Optional.empty().
         */
        Optional<Car> optCar = Optional.empty();
        /*
        Optional from a non-null value
        You can create an optional from a non-null value with the static factory method Optional.of().
        If car were null, a NullPointerException would be thrown immediately (rather than getting a latent error when
        you try to access properties of the car).
         */
        Car car = new Car();
        Optional<Car> optCar2 = Optional.of(car);
        /*
        Optional from null
        Finally, by using the static factory method Optional.ofNullable, you can create an Optional object that may hold
        a null value.
        If car2 were null, the resulting Optional object would be empty.
         */
        Car car2 = null;
        Optional<Car> optCar3 = Optional.ofNullable(car2);

        /*
        Extracting and transforming values from Optionals with map
        A common pattern is to extract information from an object. You may want to extract the name from an insurance
        company, for example. You need to check whether insurance is null before extracting the name.
         */
        Insurance insurance = null;
        String name = null;
        if (insurance != null) {
            name = insurance.getName();
        }
        /*
        Optional supports a map() method for this pattern, which works as follows. The map() operation applies the
        provided function to each element of a stream. If the Optional contains a value, the function passed as
        argument to map() transforms that value. If the Optional is empty, nothing happens.
         */
        Optional<Insurance> optInsurance = Optional.ofNullable(insurance);
        Optional<String> name2 = optInsurance.map(Insurance::getName);

        /*
        Chaining Optional objects with flatMap()
        With streams, the flatMap() method takes a function as an argument and returns another stream. This function is
        applied to each element of a stream, resulting in a stream of streams. But flatMap() has the effect of replacing
        each generated stream with the contents of that stream. In other words, all the separate streams that are
        generated by the function get amalgamated or flattened into a single stream.
         */
        /*
        Finding a car's insurance company name with Optionals
        See getCarInsuranceName() method.
         */

        /*
        Manipulating a stream of Optionals
        The Optional's stream() method, introduced in Java 9, allows you to convert an Optional with a value to a Stream
        containing only that value or an empty Optional to an equally empty Stream. This technique can be particularly
        convenient in a common case: when you have a Stream of Optional and need to transform it into another Stream
        containing only the values present in the non-empty Optional of the original Stream. As example, suppose that
        you're required to implement a method that's passed with a List<Person> and that should return a Set<String>
        containing all the distinct names of the insurance companies used by the people in that list who own a car.
        See the getCarInsuranceNames() method.
         */

        /*
        Default actions and unwrapping an Optional
        The Optional class provides several instance methods to read the value contained by an Optional instance:
            - get() is the simples but also the least safe of these methods. It returns the wrapped value if one is
            present and throws a NoSuchElementException otherwise.
            - orElse(T other) is the method that allows you to provide a default value when the optional doesn't contain
            a value.
            - orElseGet(Supplier<? extends T> other) is the lazy counterpart of the orElse() method, because the
            supplier is invoked only if the optional contains no value. You should use this method when the default
            value is time-consuming to create (to gain efficiency) or you want the supplier to be invoked only if the
            optional is empty (when using orElseGet() is vital).
            - or(Supplier<? extends Optional<? extends T>> supplier) is similar to the former orElseGet() method, but it
            doesn't unwrap the value inside the Optional, if present. In practice, this method doesn't perform any
            action and returns the Optional as it is when it contains a value, but lazily provides a different Optional
            when the original one is empty.
            - orElseThrow(Supplier<? extends X> exceptionSupplier) is similar to the get() method in that it throws an
            exception when the optional is empty, but it allows you to choose the type of exception that you want to
            throw.
            - ifPresent(Consumer<? super T> consumer) lets you execute the action given as argument if a value is
            present; otherwise, no action is taken.
            - ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction). This differs from ifPresent() by taking
            a Runnable that gives an empty-based action to be executed when the Optional is empty.
         */

    }

    public static String getCarInsuranceName(Optional<Person> person) {
        return person.flatMap(Person::getCar)
                .flatMap(Car::getInsurance)
                .map(Insurance::getName)
                .orElse("Unknown");
    }

    public static Set<String> getCarInsuranceNames(List<Person> persons) {
        return persons.stream() // Stream<Person>
                .map(Person::getCar) // Stream<Optional<...>> | Convert the list of persons into a Stream of Optional<Car> with the cars eventually owned by them.
                .map(optCar -> optCar.flatMap(Car::getInsurance)) // // Stream<Optional<...>> | FlatMap each Optional<Car> into the corresponding Optional<Insurance>
                .map(optIns -> optIns.map(Insurance::getName)) // // Stream<Optional<...>> | Map each Optional<Insurance> into the Optional<String> containing the corresponding name.
                .flatMap(Optional::stream) // Transform the Stream<Optional<String>> into a Stream<String> containing only the present names.
                .collect(Collectors.toSet()); // Collect the result Strings into a Set to obtain only the distinct values.
    }
}
